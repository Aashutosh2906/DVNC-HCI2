#!/usr/bin/env python3
"""
DVNC.AI Flask Backend - Da Vinci-Inspired Product Design System
----------------------------------------------------------------
Flask API backend that processes prompts and returns da Vinci-inspired design solutions.
"""

from flask import Flask, request, jsonify
from flask_cors import CORS
import random
import re
from dataclasses import dataclass, asdict
from typing import List, Tuple, Dict
from enum import Enum

app = Flask(__name__)
CORS(app)  # Enable CORS for frontend communication

# ---------- Core Data Structures ----------

class DevelopmentStage(Enum):
    """Stages of technical readiness for a design feature."""
    CONCEPT = 1
    PROTOTYPE = 2
    PRODUCTION_READY = 3

@dataclass
class DesignFeature:
    """A specific, actionable feature of a product design."""
    description: str
    inspiration: str
    development_stage: DevelopmentStage
    engineering_notes: str

@dataclass
class DesignCandidate:
    """Represents a commercially viable design candidate generated by the system."""
    name: str
    product_type: str
    core_innovation: str
    features: List[DesignFeature]
    target_market: str
    innovation_score: int
    feasibility_score: int
    viability_score: float
    da_vinci_principles: List[str]

# ---------- Enhanced Grouped Knowledge Verticals for SLMs ----------

def get_mechanics_physics_insights() -> List[Tuple[str, str]]:
    """Insights for Mechanics & Physics SLM."""
    return [
        ("Pyramidal law of force: power diminishes towards its end.", "Madrid I, 16r - Studies of spring mechanics"),
        ("Water seeks the most efficient path; design channels to guide flow, not resist it.", "Codex Leicester - Studies of water vortices"),
        ("Structural efficiency through geometric forms and arches.", "Studies of architecture and the Tiburio of Milan Cathedral"),
        ("Use of worm gears and stable axle bearings for compact power transmission.", "Madrid I - Codice Atlantico mechanical studies"),
        ("Motion is the cause of every life.", "Trattato della Pittura - On motion"),
        ("Mechanics is the paradise of the mathematical sciences.", "Notebook E"),
    ]

def get_anatomy_biology_insights() -> List[Tuple[str, str]]:
    """Insights for Anatomy & Biology SLM."""
    return [
        ("The nerve chords serve the sensus communis as the officers serve their captain.", "W.19019r - Anatomical studies of the brain"),
        ("Proportional harmony based on the Vitruvian system.", "Venice Accademia - Proportional Study of a Man"),
        ("Layered system integration (like muscle, tendon, bone).", "Anatomical drawings - Cross Sections of the Human Skull"),
        ("Study bird anatomy for biomimetic flight devices.", "Windsor Manuscripts - Anatomy of birds"),
        ("Learn from nature: that is where our future lies.", "Unknown"),
        ("The human foot is a masterpiece of engineering and a work of art.", "Unknown"),
    ]

def get_optics_aesthetics_insights() -> List[Tuple[str, str]]:
    """Insights for Optics & Aesthetics SLM."""
    return [
        ("Shadow is of greater power than light.", "Ash.II, 21r - Treatise on Painting"),
        ("Sfumato: do not make definite or sharp boundaries.", "Ash.II, 14v - Treatise on Painting"),
        ("Use contrast (light/dark) to emphasize important elements.", "Study of Light and Shade - Windsor 12431v"),
        ("Atmospheric perspective: distant objects lose clarity.", "Background of the Mona Lisa"),
        ("Golden ratio in natural and man-made designs.", "Paciolian influences - Divine Proportion"),
        ("Light is the expeller of darkness.", "Unknown"),
    ]

# ---------- SLM Functions ----------

def mechanics_physics_slm(product_type: str) -> List[Dict]:
    """Mechanics & Physics SLM: Generates feature ideas."""
    insights = get_mechanics_physics_insights()
    selected = random.sample(insights, k=random.randint(2, 3))
    features = []
    for concept, source in selected:
        desc = f"Apply {concept.split(':')[0].lower().strip()} to enhance mechanical efficiency in the {product_type}."
        features.append({
            "description": desc,
            "inspiration": f"{concept} || Source: {source}",
            "domain": "Mechanics & Physics"
        })
    return features

def anatomy_biology_slm(product_type: str) -> List[Dict]:
    """Anatomy & Biology SLM: Generates feature ideas."""
    insights = get_anatomy_biology_insights()
    selected = random.sample(insights, k=random.randint(2, 3))
    features = []
    for concept, source in selected:
        desc = f"Incorporate {concept.split(':')[0].lower().strip()} for biomimetic ergonomics in the {product_type}."
        features.append({
            "description": desc,
            "inspiration": f"{concept} || Source: {source}",
            "domain": "Anatomy & Biology"
        })
    return features

def optics_aesthetics_slm(product_type: str) -> List[Dict]:
    """Optics & Aesthetics SLM: Generates feature ideas."""
    insights = get_optics_aesthetics_insights()
    selected = random.sample(insights, k=random.randint(2, 3))
    features = []
    for concept, source in selected:
        desc = f"Integrate {concept.split(':')[0].lower().strip()} for visual harmony in the {product_type}."
        features.append({
            "description": desc,
            "inspiration": f"{concept} || Source: {source}",
            "domain": "Optics & Aesthetics"
        })
    return features

# ---------- Da Vinci Abstraction Organ ----------

def da_vinci_abstraction_organ(product_type: str, slm_outputs: List[List[Dict]]) -> List[Dict]:
    """Synthesizes outputs from the 3 SLMs."""
    all_ideas = [idea for slm in slm_outputs for idea in slm]
    selected_ideas = random.sample(all_ideas, k=min(len(all_ideas), random.randint(4, 6)))
    features = []
    
    for idea in selected_ideas:
        stage_weights = [(.15, "CONCEPT"), (.45, "PROTOTYPE"), (.4, "PRODUCTION_READY")]
        weights, stages = zip(*stage_weights)
        stage = random.choices(stages, weights=weights, k=1)[0]
        
        if stage == "CONCEPT":
            note = "Conceptual exploration; requires validation through modeling."
        elif stage == "PROTOTYPE":
            note = "Prototype feasible with current technology; refine through iteration."
        else:
            note = "Production-ready using established manufacturing processes."
        
        features.append({
            "description": idea["description"],
            "inspiration": idea["inspiration"],
            "development_stage": stage,
            "engineering_notes": note,
            "domain": idea["domain"]
        })
    
    return features

# ---------- Processing Functions ----------

def process_prompt(prompt: str) -> Dict:
    """Process the user prompt and return design candidate."""
    # Clean the prompt
    product_type = re.sub(r'^(develop|design|create|build)\s+(a|an|the)?\s*', '', prompt.lower())
    product_type = product_type.strip()
    
    # Run SLMs
    slm1 = mechanics_physics_slm(product_type)
    slm2 = anatomy_biology_slm(product_type)
    slm3 = optics_aesthetics_slm(product_type)
    
    # Store SLM outputs for response
    slm_outputs = {
        "mechanics": slm1,
        "anatomy": slm2,
        "optics": slm3
    }
    
    # Synthesize features
    all_slm_outputs = [slm1, slm2, slm3]
    features = da_vinci_abstraction_organ(product_type, all_slm_outputs)
    
    # Generate scores
    innovation = random.randint(7, 10)
    feasibility = random.randint(7, 10)
    viability = round((innovation * 0.4 + feasibility * 0.6) / 10 * random.uniform(0.95, 1.1), 2)
    
    # Generate design name
    name_parts = ["Vitruvian", "Sfumato", "Codex", "Renaissance"]
    product_words = product_type.split()
    name = f"{random.choice(name_parts)} {product_words[0].capitalize() if product_words else 'Design'}"
    
    # Select target market
    markets = ["Consumer Electronics", "Industrial Equipment", "Medical Devices", 
               "Sustainable Goods", "Home Appliances", "Wearables", "Professional Tools"]
    target_market = random.choice(markets)
    
    # Identify which codices to reference
    codices = []
    for feature in features:
        if "Codex Atlanticus" in feature["inspiration"] and "Codex Atlanticus" not in codices:
            codices.append({"name": "Codex Atlanticus", "icon": "üìú"})
        if "Codex Leicester" in feature["inspiration"] and "Codex Leicester" not in codices:
            codices.append({"name": "Codex Leicester", "icon": "üìñ"})
        if "Windsor" in feature["inspiration"] and "Windsor Manuscripts" not in codices:
            codices.append({"name": "Windsor Manuscripts", "icon": "üìö"})
        if "Madrid" in feature["inspiration"] and "Codex Madrid" not in codices:
            codices.append({"name": "Codex Madrid I", "icon": "üìù"})
    
    if len(codices) == 0:  # Add default codices if none matched
        codices = [
            {"name": "Codex Atlanticus", "icon": "üìú"},
            {"name": "Windsor Manuscripts", "icon": "üìö"}
        ]
    
    return {
        "name": name,
        "product_type": product_type,
        "core_innovation": "Synthesized via Da Vinci Abstraction Organ for holistic innovation",
        "features": features,
        "target_market": target_market,
        "innovation_score": innovation,
        "feasibility_score": feasibility,
        "viability_score": viability,
        "principles": ["Mechanics & Physics", "Anatomy & Biology", "Optics & Aesthetics"],
        "slm_outputs": slm_outputs,
        "codices": codices
    }

# ---------- API Routes ----------

@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint."""
    return jsonify({"status": "healthy", "service": "DVNC.AI Backend"})

@app.route('/api/process', methods=['POST'])
def process_design():
    """Process a design prompt and return Leonardo-inspired solution."""
    try:
        data = request.json
        prompt = data.get('prompt', '')
        
        if not prompt:
            return jsonify({"error": "No prompt provided"}), 400
        
        # Process the prompt
        result = process_prompt(prompt)
        
        # Format response for frontend
        response = {
            "success": True,
            "design": result,
            "message": f"Generated {result['name']} - a {result['product_type']} design inspired by Leonardo da Vinci's principles."
        }
        
        return jsonify(response)
    
    except Exception as e:
        return jsonify({"error": str(e), "success": False}), 500

@app.route('/api/prompts', methods=['GET'])
def get_prompts():
    """Return suggested prompts for the frontend."""
    prompts = [
        {
            "prompt": "Develop a portable water pump system inspired by fluid dynamics principles",
            "category": "Hydraulic Engineering",
            "description": "Portable water pump system with fluid dynamics"
        },
        {
            "prompt": "Design an exoskeleton suit that enhances joint articulation for heavy lifting",
            "category": "Biomechanical Design",
            "description": "Exoskeleton for enhanced joint articulation"
        },
        {
            "prompt": "Create a wearable device that monitors the circulatory system during exercise",
            "category": "Biomedical Innovation",
            "description": "Wearable circulatory system monitor"
        }
    ]
    return jsonify(prompts)

if __name__ == '__main__':
    # For local development
    app.run(debug=True, port=5000)
    
# For production with Vercel, create a vercel.json and requirements.txt
